import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@emotion/core';
import { Children, cloneElement, forwardRef } from 'react';
import styled from '@emotion/styled';
import { mediaQueries } from '@arch-ui/common';
import { gridSize } from '@arch-ui/theme';

// Container
// ==============================

const CONTAINER_WIDTH = 1160;
const CONTAINER_GUTTER = gridSize * 6;
const Container = styled.div(({
  isFullWidth
}) => ({
  maxWidth: isFullWidth ? '100%' : CONTAINER_WIDTH,
  paddingLeft: CONTAINER_GUTTER,
  paddingRight: CONTAINER_GUTTER,
  transition: 'max-width 200ms cubic-bezier(0.2, 0, 0, 1)',
  [mediaQueries.smOnly]: {
    paddingLeft: gridSize * 2,
    paddingRight: gridSize * 2
  }
})); // ==============================
// Fluid Group
// ==============================

function collapseBorderRadii(index, length) {
  let style;
  const isFirst = index === 0;
  const isLast = index === length - 1;

  if (isLast && !isFirst) {
    style = {
      borderTopLeftRadius: 0,
      borderBottomLeftRadius: 0
    };
  } else if (isFirst && !isLast) {
    style = {
      borderTopRightRadius: 0,
      borderBottomRightRadius: 0
    };
  } else if (!isFirst && !isLast) {
    style = {
      borderRadius: 0
    };
  }

  return style;
}

function FlexGroupComponent(_ref, ref) {
  let {
    align = 'stretch',
    as: Tag = 'div',
    children,
    growIndexes = [],
    isContiguous,
    isInline,
    isVertical,
    justify = 'flex-start',
    wrap,
    spacing = gridSize,
    stretch
  } = _ref,
      props = _objectWithoutProperties(_ref, ["align", "as", "children", "growIndexes", "isContiguous", "isInline", "isVertical", "justify", "wrap", "spacing", "stretch"]);

  const gutter = spacing / 2;
  const length = Children.count(children);
  const childArray = Children.toArray(children).filter(child => child); // filter out null and undefined children

  return jsx(Tag, _extends({
    css: {
      alignItems: align,
      display: isInline ? 'inline-flex' : 'flex',
      flexDirection: isVertical ? 'column' : 'row',
      flexWrap: wrap ? 'wrap' : 'nowrap',
      justifyContent: justify,
      marginBottom: isVertical ? -gutter : null,
      marginLeft: isContiguous || isVertical ? null : -gutter,
      marginRight: isContiguous || isVertical ? null : -gutter,
      marginTop: isVertical ? -gutter : null,
      maxWidth: isInline ? `calc(100% + ${gutter * 2}px)` : null
    },
    ref: ref
  }, props), childArray.map((child, idx) => {
    const style = isContiguous ? collapseBorderRadii(idx, length) : null;
    const leftOffset = isContiguous && idx ? -1 : gutter;
    const rightOffset = isContiguous ? null : gutter;
    return jsx("div", {
      key: child.key,
      css: {
        flex: stretch || growIndexes.includes(idx) ? 1 : null,
        marginLeft: isVertical ? null : leftOffset,
        marginRight: isVertical ? null : rightOffset,
        marginTop: isVertical ? gutter : null,
        marginBottom: isVertical ? gutter : null,
        minWidth: 0,
        // allows text-overflow on children
        // bring the focus styles over the top of siblings
        '&:focus-within': {
          position: 'relative'
        }
      }
    }, isContiguous ? /*#__PURE__*/cloneElement(child, {
      style
    }) : child);
  }));
}
const FlexGroup = /*#__PURE__*/forwardRef(FlexGroupComponent); // ==============================
// Grid
// ==============================
// Grid Parent
// --------------------

function formatAreas(areas) {
  return areas.map(area => `"${area}"`).join(' ');
}

const Grid = /*#__PURE__*/forwardRef((_ref2, ref) => {
  let {
    alignContent,
    areas,
    columns = 12,
    flow = 'row',
    gap = 8,
    justifyContent,
    minRowHeight = 20,
    rows
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["alignContent", "areas", "columns", "flow", "gap", "justifyContent", "minRowHeight", "rows"]);

  const templateRows = rows ? {
    gridTemplateRows: rows
  } : {};
  const templateAreas = areas ? {
    gridTemplateAreas: formatAreas(areas)
  } : {};
  const gridTemplateColumns = Number.isInteger(columns) ? `repeat(${columns}, 1fr)` : columns;
  return jsx("div", _extends({
    ref: ref,
    css: _objectSpread(_objectSpread({
      display: 'grid',
      gridAutoFlow: flow,
      gridAutoRows: `minmax(${minRowHeight}px, auto)`,
      gridGap: gap,
      gridTemplateColumns,
      justifyContent,
      alignContent
    }, templateRows), templateAreas)
  }, props));
});
const Cell = (_ref3) => {
  let {
    area,
    height = 1,
    left,
    top,
    width = 1
  } = _ref3,
      props = _objectWithoutProperties(_ref3, ["area", "height", "left", "top", "width"]);

  return jsx("div", _extends({
    css: {
      alignContent: 'space-around',
      gridArea: area,
      gridColumnEnd: `span ${width}`,
      gridColumnStart: left,
      gridRowEnd: `span ${height}`,
      gridRowStart: top,
      height: '100%',
      minWidth: 0
    }
  }, props));
};

export { CONTAINER_GUTTER, CONTAINER_WIDTH, Cell, Container, FlexGroup, FlexGroupComponent, Grid };
