'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var core = require('@emotion/core');
var styled = require('@emotion/styled');
var dateFns = require('date-fns');
var reactWindow = require('react-window');
var octiconsReact = require('@primer/octicons-react');
var React = require('react');
var theme = require('@arch-ui/theme');
var typography = require('@arch-ui/typography');
require('intersection-observer');
var input = require('@arch-ui/input');
var Select = require('@arch-ui/select');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var chrono = require('chrono-node');
var moment = require('moment');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var styled__default = /*#__PURE__*/_interopDefault(styled);
var React__default = /*#__PURE__*/_interopDefault(React);
var Select__default = /*#__PURE__*/_interopDefault(Select);
var chrono__default = /*#__PURE__*/_interopDefault(chrono);
var moment__default = /*#__PURE__*/_interopDefault(moment);

const yearRange = (from, to) => {
  const years = [];
  let year = from;

  while (year <= to) {
    years.push(year++);
  }

  return years;
};
const months = Array.from({
  length: 12
}, (_, i) => i); // https://github.com/geeofree/kalendaryo/blob/master/src/index.js#L245-L279

function createDayObject(dateValue) {
  return {
    dateValue,
    label: dateFns.getDate(dateValue)
  };
}

function getWeeksInMonth(date) {
  const weekOptions = {
    weekStartsOn: 0
  };
  const firstDayOfMonth = dateFns.startOfMonth(date);
  const firstDayOfFirstWeek = dateFns.startOfWeek(firstDayOfMonth, weekOptions);
  const lastDayOfFirstWeek = dateFns.endOfWeek(firstDayOfMonth, weekOptions);

  const getWeeks = (startDay, endDay, weekArray) => {
    const week = dateFns.eachDayOfInterval({
      start: startDay,
      end: endDay
    }).map(createDayObject);
    const weeks = [...weekArray, week];
    const nextWeek = dateFns.addWeeks(startDay, 1);
    const firstDayNextWeek = dateFns.startOfWeek(nextWeek, weekOptions);
    const lastDayNextWeek = dateFns.endOfWeek(nextWeek, weekOptions);

    if (dateFns.isSameMonth(firstDayNextWeek, date)) {
      return getWeeks(firstDayNextWeek, lastDayNextWeek, weeks);
    }

    return weeks;
  };

  return getWeeks(firstDayOfFirstWeek, lastDayOfFirstWeek, []);
}
function isNumberInRange(num, start, end) {
  return num >= start && num <= end;
}
function usePrevious(value) {
  const ref = React.useRef(value);
  React.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

/** @jsx jsx */
const monthOptions = months.map((month, i) => core.jsx("option", {
  key: i,
  value: i
}, dateFns.format(dateFns.setMonth(new Date(), month), 'LLL')));
const SelectMonth = /*#__PURE__*/React.memo(({
  onChange,
  month
}) => {
  return core.jsx("select", {
    id: "ks-select-month",
    onChange: event => {
      onChange(Number(event.target.value));
    },
    value: month
  }, monthOptions);
});
const SelectYear = /*#__PURE__*/React.memo(({
  onChange,
  year,
  yearRangeFrom,
  yearRangeTo,
  yearPickerType
}) => {
  const years = yearRange(yearRangeFrom, yearRangeTo); // using internal state so that the user can input invalid values
  // but the parent component will only recieve valid values

  const [internalValue, setInternalValue] = React.useState(year);
  const previousYearProp = usePrevious(year);
  React.useEffect(() => {
    if (previousYearProp !== year) {
      setInternalValue(year);
    }
  }, [previousYearProp, year, setInternalValue]);

  const handleChange = event => {
    const value = Number(event.target.value);
    setInternalValue(value);

    if (isNumberInRange(value, yearRangeFrom, yearRangeTo)) {
      onChange(value);
    }
  };

  if (years.length > 50 && yearPickerType === 'auto' || yearPickerType === 'input') {
    return core.jsx("input", {
      id: "ks-input-year",
      type: "number",
      min: yearRangeFrom,
      max: yearRangeTo,
      onChange: handleChange,
      value: internalValue
    });
  } else {
    return core.jsx("select", {
      id: "ks-select-year",
      onChange: handleChange,
      value: internalValue
    }, years.map((yearOption, i) => core.jsx("option", {
      key: i,
      value: yearOption
    }, yearOption)));
  }
});

const WeekRow = styled__default['default'].div({
  display: 'flex'
});
const WeekLabels = styled__default['default'](WeekRow)({
  color: theme.colors.N40,
  fontSize: '0.65rem',
  fontWeight: 500,
  textTransform: 'uppercase'
});
const Day = styled__default['default'].div(({
  disabled,
  isInteractive,
  isSelected,
  isToday
}) => {
  let textColor;
  if (isToday) textColor = theme.colors.danger;
  if (disabled) textColor = theme.colors.N40;
  if (isSelected) textColor = 'white';
  return {
    alignItems: 'center',
    backgroundColor: isSelected ? theme.colors.primary : null,
    borderRadius: theme.borderRadius,
    color: textColor,
    cursor: isInteractive ? 'pointer' : 'default',
    display: 'flex',
    flexDirection: 'column',
    fontWeight: isSelected || isToday ? 'bold' : null,
    flexBasis: 'calc(100% / 7)',
    padding: '0.5rem',
    textAlign: 'center',
    width: 'calc(100% / 7)',
    ':hover': {
      backgroundColor: isInteractive && !isSelected ? theme.colors.B.L90 : null,
      color: isInteractive && !isSelected && !isToday ? theme.colors.B.D40 : null
    },
    ':active': {
      backgroundColor: isInteractive && !isSelected ? theme.colors.B.L80 : null
    }
  };
});

/** @jsx jsx */
const TodayMarker = styled__default['default'].div(({
  isSelected
}) => ({
  backgroundColor: isSelected ? 'white' : theme.colors.danger,
  borderRadius: 4,
  height: 2,
  marginBottom: -4,
  marginTop: 2,
  width: '1em'
}));
const Month = /*#__PURE__*/React.memo(({
  style,
  index,
  data
}) => {
  const {
    items,
    selectedDate,
    onSelectedChange,
    observer
  } = data;
  const ref = React.useRef(null);
  React.useEffect(() => {
    const node = ref.current;

    if (node !== null) {
      observer.observe(node);
      return () => observer.unobserve(node);
    }
  }, [observer]);
  const {
    weeks,
    month,
    year
  } = items[index];
  return core.jsx("div", {
    ref: ref,
    "data-index": index,
    id: `ks-month-${month}-${year}`,
    style: style
  }, core.jsx(MonthHeader, {
    month: month,
    year: year
  }), weeks.map((week, i) => core.jsx(WeekRow, {
    key: i
  }, week.map(day => {
    const date = new Date(year, month, 3);
    const disabled = !dateFns.isSameMonth(date, day.dateValue);
    const isSelected = !disabled && selectedDate !== null && dateFns.isEqual(selectedDate, day.dateValue);
    const isToday = dateFns.isToday(day.dateValue);
    return core.jsx(Day, {
      id: `ks-day-${day.label}-${month}-${year}`,
      key: day.label,
      disabled: disabled,
      onClick: disabled ? null : () => onSelectedChange(day.dateValue),
      isInteractive: !disabled,
      isSelected: isSelected,
      isToday: isToday
    }, day.label, isToday ? core.jsx(TodayMarker, {
      isSelected: isSelected
    }) : null);
  }))));
});
const readableMonths = months.map(month => dateFns.format(dateFns.setMonth(new Date(), month), 'LLLL'));
const MonthHeader = /*#__PURE__*/React.memo(({
  month,
  year
}) => {
  return core.jsx("div", {
    css: {
      position: 'sticky',
      top: 0,
      width: '100%',
      backgroundColor: '#fff'
    }
  }, core.jsx("div", {
    css: {
      paddingTop: 4,
      paddingBottom: 4,
      border: `1px ${theme.colors.N60} solid`,
      borderLeft: 0,
      borderRight: 0,
      display: 'flex',
      justifyContent: 'space-between',
      paddingRight: 12
    }
  }, core.jsx("span", {
    css: {
      color: theme.colors.N60
    }
  }, readableMonths[month]), core.jsx("span", {
    css: {
      color: theme.colors.N60
    }
  }, year)));
});

const Wrapper = styled__default['default'].div({
  fontSize: '0.85rem'
});
const Header = styled__default['default'].div({
  alignItems: 'center',
  display: 'flex',
  justifyContent: 'space-between'
});

const HeaderButton = props => core.jsx("button", _extends({
  type: "button",
  css: {
    background: 'none',
    borderRadius: theme.borderRadius,
    border: 'none',
    cursor: 'pointer',
    padding: '0.5rem 0.75rem',
    outline: 'none',
    ':hover': {
      backgroundColor: theme.colors.N05
    },
    ':active': {
      backgroundColor: theme.colors.N10
    }
  }
}, props));

let DAY_HEIGHT = 32.5;

function scrollToDate(date, yearRangeFrom, yearRangeTo, list) {
  if (list !== null) {
    const year = dateFns.getYear(date);
    const month = date.getMonth(); // calculate the index instead of using find because this is much cheaper

    const index = (year - yearRangeFrom) * 12 + month;
    list.scrollToItem(index, 'start');
  }
}

let weekLabels = core.jsx(WeekLabels, null, [...new Array(7)].map((_, day) => dateFns.format(dateFns.setDay(new Date(), day), 'iii')).map(d => core.jsx(Day, {
  key: d
}, d))); // this component will rerender a lot really quickly
// so there's lots of memoization

const DayPicker = ({
  yearRangeFrom = dateFns.getYear(new Date()) - 100,
  yearRangeTo = dateFns.getYear(new Date()),
  yearPickerType = 'auto',
  startCurrentDateAt,
  selectedDate,
  onSelectedChange
}) => {
  const listRef = React.useRef(null);

  if (!isNumberInRange(startCurrentDateAt.getFullYear(), yearRangeFrom, yearRangeTo)) {
    // if startCurrentDateAt is out of the year range then we go to end of
    // the year of yearRangeTo, ideally we'd throw an error for this case
    // and fix all the incorrect values for startCurrentDateAt but that
    // would require a bunch of other changes so it just isn't worth it right now
    // since we're planning to change a lot of this stuff anyway
    let date = new Date();
    date.setFullYear(yearRangeTo);
    startCurrentDateAt = dateFns.endOfYear(date);
  }

  const [date, setDate] = React.useState(startCurrentDateAt);
  const shouldChangeScrollPositionRef = React.useRef(true);
  const controlledSetDate = React.useCallback(newDate => {
    shouldChangeScrollPositionRef.current = true;
    setDate(newDate);
  }, [shouldChangeScrollPositionRef, setDate]);
  React.useLayoutEffect(() => {
    if (shouldChangeScrollPositionRef.current) {
      scrollToDate(date, yearRangeFrom, yearRangeTo, listRef.current);
      shouldChangeScrollPositionRef.current = false;
    }
  }, [date, yearRangeFrom, yearRangeTo, listRef]);
  const years = React.useMemo(() => {
    return yearRange(yearRangeFrom, yearRangeTo);
  }, [yearRangeFrom, yearRangeTo]);
  const items = React.useMemo(() => {
    const _items = [];
    years.forEach(year => {
      months.forEach(month => {
        _items.push({
          year,
          month,
          weeks: getWeeksInMonth(new Date(year, month, 1))
        });
      });
    });
    return _items;
  }, [years]);
  const currentIndex = (date.getFullYear() - yearRangeFrom) * 12 + date.getMonth();
  const canGoNextMonth = currentIndex < items.length - 1;
  const canGoPreviousMonth = currentIndex > 0;
  const observer = React.useMemo(() => {
    return new IntersectionObserver(entries => {
      const filteredEntries = entries.filter(value => value.isIntersecting).sort((a, b) => {
        if (a.intersectionRatio > b.intersectionRatio) {
          return -1;
        }

        return 1;
      });

      if (filteredEntries.length !== 0) {
        let index = Number(filteredEntries[0].target.getAttribute('data-index'));
        let item = items[index];
        setDate(new Date(item.year, item.month, 1));
      }
    }, {
      threshold: 0.6
    });
  }, [items]);
  return core.jsx(Wrapper, null, core.jsx(Header, null, React.useMemo(() => core.jsx(HeaderButton, {
    disabled: !canGoPreviousMonth,
    onClick: () => {
      controlledSetDate(currentDate => dateFns.subMonths(currentDate, 1));
    }
  }, core.jsx(octiconsReact.ChevronLeftIcon, null), core.jsx(typography.A11yText, null, "Previous Month")), [controlledSetDate, canGoPreviousMonth]), core.jsx(SelectMonth, {
    onChange: React.useCallback(month => {
      controlledSetDate(currentDate => {
        return dateFns.setMonth(currentDate, month);
      });
    }, [controlledSetDate]),
    month: date.getMonth()
  }), core.jsx(SelectYear, {
    year: dateFns.getYear(date),
    onChange: React.useCallback(year => {
      controlledSetDate(currentDate => {
        return dateFns.setYear(currentDate, year);
      });
    }, [controlledSetDate]),
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType
  }), React.useMemo(() => core.jsx(HeaderButton, {
    disabled: !canGoNextMonth,
    onClick: () => {
      controlledSetDate(currentDate => dateFns.addMonths(currentDate, 1));
    }
  }, core.jsx(octiconsReact.ChevronRightIcon, null), core.jsx(typography.A11yText, null, "Next Month")), [controlledSetDate, canGoNextMonth])), core.jsx("div", null, weekLabels, core.jsx(reactWindow.VariableSizeList, {
    ref: listRef,
    itemSize: React.useCallback(index => {
      const {
        weeks
      } = items[index];
      return weeks.length * DAY_HEIGHT + 26.5;
    }, [items]),
    itemData: React.useMemo(() => ({
      items,
      selectedDate,
      onSelectedChange,
      observer
    }), [items, selectedDate, onSelectedChange, observer]),
    height: 6 * DAY_HEIGHT + 26.5,
    itemCount: years.length * 12,
    width: "100%"
  }, Month)));
};

const options = ['-12', '-11', '-10', '-09', '-08', '-07', '-06', '-05', '-04', '-03', '-02', '-01', '+00', '+01', '+02', '+03', '+04', '+05', '+06', '+07', '+08', '+09', '+10', '+11', '+12', '+13', '+14'].map(o => ({
  value: `${o}:00`,
  label: `${o}:00`
}));
const DayTimePicker = props => {
  const {
    date,
    time,
    offset,
    htmlID,
    autoFocus,
    isDisabled
  } = props;
  const {
    handleDayChange,
    handleTimeChange,
    handleOffsetChange,
    yearRangeFrom,
    yearRangeTo,
    yearPickerType
  } = props;
  const TODAY = new Date();
  return /*#__PURE__*/React.createElement("div", {
    id: htmlID
  }, /*#__PURE__*/React.createElement(DayPicker, {
    autoFocus: autoFocus,
    onSelectedChange: handleDayChange,
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType,
    startCurrentDateAt: date ? dateFns.parseISO(date) : TODAY,
    selectedDate: date ? dateFns.parseISO(date) : null
  }), /*#__PURE__*/React.createElement(input.Input, {
    type: "time",
    name: "time-picker",
    value: time,
    onChange: handleTimeChange,
    disabled: isDisabled || false,
    id: `${htmlID}-time`
  }), /*#__PURE__*/React.createElement(Select__default['default'], {
    value: options.find(option => option.value === offset),
    options: options,
    onChange: ({
      value
    }) => {
      handleOffsetChange(value);
    },
    id: `${htmlID}-offset`
  }));
};

const TextDayPicker = /*#__PURE__*/React.forwardRef((_ref, ref) => {
  let {
    date = '',
    onChange,
    format: displayFormat = 'do MMMM yyyy'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["date", "onChange", "format"]);

  const formatDate = newDate => newDate ? dateFns.format(dateFns.parseISO(newDate), displayFormat) : '';

  const [isEditing, setIsEditing] = React.useState(false);
  const [value, setValue] = React.useState({
    raw: date,
    formatted: formatDate(date)
  });
  const parseCache = React.useRef();
  React.useEffect(() => {
    // Parse the raw input. This may be a string such as 'Today'.
    const parsedDate = chrono__default['default'].parseDate(value.raw); // If valid, convert it to ISO 8601.

    const isoDate = parsedDate ? dateFns.formatISO(parsedDate, {
      representation: 'date'
    }) : null; // Pass it up the tree. The parent can handle the null case.

    onChange(isoDate);
    parseCache.current = isoDate;
  }, [value.raw]);

  const onFocus = () => {
    setIsEditing(true);
  };

  const onBlur = () => {
    setIsEditing(false);
    const raw = parseCache.current; // At this point, the parse cache should either be null or an ISO 8601 date.

    if (raw) {
      setValue({
        raw,
        formatted: formatDate(raw)
      });
    } else {
      setValue({
        raw: '',
        formatted: ''
      });
    }
  };

  const handleChange = ({
    target: {
      value: raw
    }
  }) => {
    setValue(oldValue => _objectSpread(_objectSpread({}, oldValue), {}, {
      raw
    }));
  };

  return /*#__PURE__*/React__default['default'].createElement(input.Input, _extends({
    ref: ref,
    value: isEditing ? value.raw : value.formatted,
    placeholder: "Enter a date...",
    onFocus: onFocus,
    onBlur: onBlur,
    onChange: handleChange
  }, props));
});

let TextDayTimePicker = (_ref) => {
  let {
    date,
    onChange
  } = _ref,
      props = _objectWithoutProperties(_ref, ["date", "onChange"]);

  let [value, setValue] = React.useState('');
  let ref = React.useRef(null);
  React.useEffect(() => {
    setValue(formatDateTime(date));
  }, [date]);
  return core.jsx(input.Input, _extends({
    value: value,
    ref: ref,
    placeholder: "Enter a date and time...",
    onBlur: () => {
      let parsedDate = parseDate(value);
      onChange(parsedDate);
      setValue(formatDateTime(parsedDate));
    },
    onChange: event => {
      setValue(event.target.value);
    }
  }, props));
};

function formatDateTime(date) {
  // why are we using moment when it's so large and provides a mutable API?
  // because chrono uses it and consistency is nice and
  // will probably make bugs with conversion less likely
  return date ? moment__default['default'].parseZone(date).format('h:mm A Do MMMM YYYY Z') : '';
}

function parseDate(value) {
  let [parsedDate] = chrono__default['default'].parse(value);

  if (parsedDate === undefined) {
    return null;
  }

  let dateMoment = parsedDateToMoment(parsedDate);
  return dateMoment.toISOString( // passing true here keeps the offset in the iso string rather than
  // convert it to UTC which is the default to align with native JS Dates
  true);
}

function parsedDateToMoment(parsedDate) {
  // a copy of https://github.com/wanasit/chrono/blob/fe8db4e5e5f9b44215f96958c811f806458013e9/src/result.js#L102-L122
  // with one change, rather than adjusting the time to the timezone offset, we store the offset
  let dateMoment = moment__default['default']();
  let currentTimezoneOffset = moment__default['default']().utcOffset();
  let {
    start
  } = parsedDate;
  dateMoment.set('year', start.get('year'));
  dateMoment.set('month', start.get('month') - 1);
  dateMoment.set('date', start.get('day'));
  dateMoment.set('hour', start.get('hour'));
  dateMoment.set('minute', start.get('minute'));
  dateMoment.set('second', start.get('second'));
  dateMoment.set('millisecond', start.get('millisecond'));
  let targetTimezoneOffset = start.get('timezoneOffset') !== undefined ? start.get('timezoneOffset') : currentTimezoneOffset;
  dateMoment.utcOffset(targetTimezoneOffset, // passing true keeps the local time the same but changes the universal time
  // this is what we want because we're setting the local time above
  true);
  return dateMoment;
}

exports.DayPicker = DayPicker;
exports.DayTimePicker = DayTimePicker;
exports.TextDayPicker = TextDayPicker;
exports.TextDayTimePicker = TextDayTimePicker;
