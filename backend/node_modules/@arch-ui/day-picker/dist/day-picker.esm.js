import _extends from '@babel/runtime/helpers/esm/extends';
import { jsx } from '@emotion/core';
import styled from '@emotion/styled';
import { startOfMonth, startOfWeek, endOfWeek, eachDayOfInterval, addWeeks, isSameMonth, getDate, format, setMonth, isEqual, isToday, setDay, getYear, endOfYear, subMonths, setYear, addMonths, parseISO, formatISO } from 'date-fns';
import { VariableSizeList } from 'react-window';
import { ChevronLeftIcon, ChevronRightIcon } from '@primer/octicons-react';
import React, { useRef, useEffect, memo, useState, useCallback, useLayoutEffect, useMemo, createElement, forwardRef } from 'react';
import { colors, borderRadius } from '@arch-ui/theme';
import { A11yText } from '@arch-ui/typography';
import 'intersection-observer';
import { Input } from '@arch-ui/input';
import Select from '@arch-ui/select';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import chrono from 'chrono-node';
import moment from 'moment';

const yearRange = (from, to) => {
  const years = [];
  let year = from;

  while (year <= to) {
    years.push(year++);
  }

  return years;
};
const months = Array.from({
  length: 12
}, (_, i) => i); // https://github.com/geeofree/kalendaryo/blob/master/src/index.js#L245-L279

function createDayObject(dateValue) {
  return {
    dateValue,
    label: getDate(dateValue)
  };
}

function getWeeksInMonth(date) {
  const weekOptions = {
    weekStartsOn: 0
  };
  const firstDayOfMonth = startOfMonth(date);
  const firstDayOfFirstWeek = startOfWeek(firstDayOfMonth, weekOptions);
  const lastDayOfFirstWeek = endOfWeek(firstDayOfMonth, weekOptions);

  const getWeeks = (startDay, endDay, weekArray) => {
    const week = eachDayOfInterval({
      start: startDay,
      end: endDay
    }).map(createDayObject);
    const weeks = [...weekArray, week];
    const nextWeek = addWeeks(startDay, 1);
    const firstDayNextWeek = startOfWeek(nextWeek, weekOptions);
    const lastDayNextWeek = endOfWeek(nextWeek, weekOptions);

    if (isSameMonth(firstDayNextWeek, date)) {
      return getWeeks(firstDayNextWeek, lastDayNextWeek, weeks);
    }

    return weeks;
  };

  return getWeeks(firstDayOfFirstWeek, lastDayOfFirstWeek, []);
}
function isNumberInRange(num, start, end) {
  return num >= start && num <= end;
}
function usePrevious(value) {
  const ref = useRef(value);
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

/** @jsx jsx */
const monthOptions = months.map((month, i) => jsx("option", {
  key: i,
  value: i
}, format(setMonth(new Date(), month), 'LLL')));
const SelectMonth = /*#__PURE__*/memo(({
  onChange,
  month
}) => {
  return jsx("select", {
    id: "ks-select-month",
    onChange: event => {
      onChange(Number(event.target.value));
    },
    value: month
  }, monthOptions);
});
const SelectYear = /*#__PURE__*/memo(({
  onChange,
  year,
  yearRangeFrom,
  yearRangeTo,
  yearPickerType
}) => {
  const years = yearRange(yearRangeFrom, yearRangeTo); // using internal state so that the user can input invalid values
  // but the parent component will only recieve valid values

  const [internalValue, setInternalValue] = useState(year);
  const previousYearProp = usePrevious(year);
  useEffect(() => {
    if (previousYearProp !== year) {
      setInternalValue(year);
    }
  }, [previousYearProp, year, setInternalValue]);

  const handleChange = event => {
    const value = Number(event.target.value);
    setInternalValue(value);

    if (isNumberInRange(value, yearRangeFrom, yearRangeTo)) {
      onChange(value);
    }
  };

  if (years.length > 50 && yearPickerType === 'auto' || yearPickerType === 'input') {
    return jsx("input", {
      id: "ks-input-year",
      type: "number",
      min: yearRangeFrom,
      max: yearRangeTo,
      onChange: handleChange,
      value: internalValue
    });
  } else {
    return jsx("select", {
      id: "ks-select-year",
      onChange: handleChange,
      value: internalValue
    }, years.map((yearOption, i) => jsx("option", {
      key: i,
      value: yearOption
    }, yearOption)));
  }
});

const WeekRow = styled.div({
  display: 'flex'
});
const WeekLabels = styled(WeekRow)({
  color: colors.N40,
  fontSize: '0.65rem',
  fontWeight: 500,
  textTransform: 'uppercase'
});
const Day = styled.div(({
  disabled,
  isInteractive,
  isSelected,
  isToday
}) => {
  let textColor;
  if (isToday) textColor = colors.danger;
  if (disabled) textColor = colors.N40;
  if (isSelected) textColor = 'white';
  return {
    alignItems: 'center',
    backgroundColor: isSelected ? colors.primary : null,
    borderRadius: borderRadius,
    color: textColor,
    cursor: isInteractive ? 'pointer' : 'default',
    display: 'flex',
    flexDirection: 'column',
    fontWeight: isSelected || isToday ? 'bold' : null,
    flexBasis: 'calc(100% / 7)',
    padding: '0.5rem',
    textAlign: 'center',
    width: 'calc(100% / 7)',
    ':hover': {
      backgroundColor: isInteractive && !isSelected ? colors.B.L90 : null,
      color: isInteractive && !isSelected && !isToday ? colors.B.D40 : null
    },
    ':active': {
      backgroundColor: isInteractive && !isSelected ? colors.B.L80 : null
    }
  };
});

/** @jsx jsx */
const TodayMarker = styled.div(({
  isSelected
}) => ({
  backgroundColor: isSelected ? 'white' : colors.danger,
  borderRadius: 4,
  height: 2,
  marginBottom: -4,
  marginTop: 2,
  width: '1em'
}));
const Month = /*#__PURE__*/memo(({
  style,
  index,
  data
}) => {
  const {
    items,
    selectedDate,
    onSelectedChange,
    observer
  } = data;
  const ref = useRef(null);
  useEffect(() => {
    const node = ref.current;

    if (node !== null) {
      observer.observe(node);
      return () => observer.unobserve(node);
    }
  }, [observer]);
  const {
    weeks,
    month,
    year
  } = items[index];
  return jsx("div", {
    ref: ref,
    "data-index": index,
    id: `ks-month-${month}-${year}`,
    style: style
  }, jsx(MonthHeader, {
    month: month,
    year: year
  }), weeks.map((week, i) => jsx(WeekRow, {
    key: i
  }, week.map(day => {
    const date = new Date(year, month, 3);
    const disabled = !isSameMonth(date, day.dateValue);
    const isSelected = !disabled && selectedDate !== null && isEqual(selectedDate, day.dateValue);
    const isToday$1 = isToday(day.dateValue);
    return jsx(Day, {
      id: `ks-day-${day.label}-${month}-${year}`,
      key: day.label,
      disabled: disabled,
      onClick: disabled ? null : () => onSelectedChange(day.dateValue),
      isInteractive: !disabled,
      isSelected: isSelected,
      isToday: isToday$1
    }, day.label, isToday$1 ? jsx(TodayMarker, {
      isSelected: isSelected
    }) : null);
  }))));
});
const readableMonths = months.map(month => format(setMonth(new Date(), month), 'LLLL'));
const MonthHeader = /*#__PURE__*/memo(({
  month,
  year
}) => {
  return jsx("div", {
    css: {
      position: 'sticky',
      top: 0,
      width: '100%',
      backgroundColor: '#fff'
    }
  }, jsx("div", {
    css: {
      paddingTop: 4,
      paddingBottom: 4,
      border: `1px ${colors.N60} solid`,
      borderLeft: 0,
      borderRight: 0,
      display: 'flex',
      justifyContent: 'space-between',
      paddingRight: 12
    }
  }, jsx("span", {
    css: {
      color: colors.N60
    }
  }, readableMonths[month]), jsx("span", {
    css: {
      color: colors.N60
    }
  }, year)));
});

const Wrapper = styled.div({
  fontSize: '0.85rem'
});
const Header = styled.div({
  alignItems: 'center',
  display: 'flex',
  justifyContent: 'space-between'
});

const HeaderButton = props => jsx("button", _extends({
  type: "button",
  css: {
    background: 'none',
    borderRadius: borderRadius,
    border: 'none',
    cursor: 'pointer',
    padding: '0.5rem 0.75rem',
    outline: 'none',
    ':hover': {
      backgroundColor: colors.N05
    },
    ':active': {
      backgroundColor: colors.N10
    }
  }
}, props));

let DAY_HEIGHT = 32.5;

function scrollToDate(date, yearRangeFrom, yearRangeTo, list) {
  if (list !== null) {
    const year = getYear(date);
    const month = date.getMonth(); // calculate the index instead of using find because this is much cheaper

    const index = (year - yearRangeFrom) * 12 + month;
    list.scrollToItem(index, 'start');
  }
}

let weekLabels = jsx(WeekLabels, null, [...new Array(7)].map((_, day) => format(setDay(new Date(), day), 'iii')).map(d => jsx(Day, {
  key: d
}, d))); // this component will rerender a lot really quickly
// so there's lots of memoization

const DayPicker = ({
  yearRangeFrom = getYear(new Date()) - 100,
  yearRangeTo = getYear(new Date()),
  yearPickerType = 'auto',
  startCurrentDateAt,
  selectedDate,
  onSelectedChange
}) => {
  const listRef = useRef(null);

  if (!isNumberInRange(startCurrentDateAt.getFullYear(), yearRangeFrom, yearRangeTo)) {
    // if startCurrentDateAt is out of the year range then we go to end of
    // the year of yearRangeTo, ideally we'd throw an error for this case
    // and fix all the incorrect values for startCurrentDateAt but that
    // would require a bunch of other changes so it just isn't worth it right now
    // since we're planning to change a lot of this stuff anyway
    let date = new Date();
    date.setFullYear(yearRangeTo);
    startCurrentDateAt = endOfYear(date);
  }

  const [date, setDate] = useState(startCurrentDateAt);
  const shouldChangeScrollPositionRef = useRef(true);
  const controlledSetDate = useCallback(newDate => {
    shouldChangeScrollPositionRef.current = true;
    setDate(newDate);
  }, [shouldChangeScrollPositionRef, setDate]);
  useLayoutEffect(() => {
    if (shouldChangeScrollPositionRef.current) {
      scrollToDate(date, yearRangeFrom, yearRangeTo, listRef.current);
      shouldChangeScrollPositionRef.current = false;
    }
  }, [date, yearRangeFrom, yearRangeTo, listRef]);
  const years = useMemo(() => {
    return yearRange(yearRangeFrom, yearRangeTo);
  }, [yearRangeFrom, yearRangeTo]);
  const items = useMemo(() => {
    const _items = [];
    years.forEach(year => {
      months.forEach(month => {
        _items.push({
          year,
          month,
          weeks: getWeeksInMonth(new Date(year, month, 1))
        });
      });
    });
    return _items;
  }, [years]);
  const currentIndex = (date.getFullYear() - yearRangeFrom) * 12 + date.getMonth();
  const canGoNextMonth = currentIndex < items.length - 1;
  const canGoPreviousMonth = currentIndex > 0;
  const observer = useMemo(() => {
    return new IntersectionObserver(entries => {
      const filteredEntries = entries.filter(value => value.isIntersecting).sort((a, b) => {
        if (a.intersectionRatio > b.intersectionRatio) {
          return -1;
        }

        return 1;
      });

      if (filteredEntries.length !== 0) {
        let index = Number(filteredEntries[0].target.getAttribute('data-index'));
        let item = items[index];
        setDate(new Date(item.year, item.month, 1));
      }
    }, {
      threshold: 0.6
    });
  }, [items]);
  return jsx(Wrapper, null, jsx(Header, null, useMemo(() => jsx(HeaderButton, {
    disabled: !canGoPreviousMonth,
    onClick: () => {
      controlledSetDate(currentDate => subMonths(currentDate, 1));
    }
  }, jsx(ChevronLeftIcon, null), jsx(A11yText, null, "Previous Month")), [controlledSetDate, canGoPreviousMonth]), jsx(SelectMonth, {
    onChange: useCallback(month => {
      controlledSetDate(currentDate => {
        return setMonth(currentDate, month);
      });
    }, [controlledSetDate]),
    month: date.getMonth()
  }), jsx(SelectYear, {
    year: getYear(date),
    onChange: useCallback(year => {
      controlledSetDate(currentDate => {
        return setYear(currentDate, year);
      });
    }, [controlledSetDate]),
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType
  }), useMemo(() => jsx(HeaderButton, {
    disabled: !canGoNextMonth,
    onClick: () => {
      controlledSetDate(currentDate => addMonths(currentDate, 1));
    }
  }, jsx(ChevronRightIcon, null), jsx(A11yText, null, "Next Month")), [controlledSetDate, canGoNextMonth])), jsx("div", null, weekLabels, jsx(VariableSizeList, {
    ref: listRef,
    itemSize: useCallback(index => {
      const {
        weeks
      } = items[index];
      return weeks.length * DAY_HEIGHT + 26.5;
    }, [items]),
    itemData: useMemo(() => ({
      items,
      selectedDate,
      onSelectedChange,
      observer
    }), [items, selectedDate, onSelectedChange, observer]),
    height: 6 * DAY_HEIGHT + 26.5,
    itemCount: years.length * 12,
    width: "100%"
  }, Month)));
};

const options = ['-12', '-11', '-10', '-09', '-08', '-07', '-06', '-05', '-04', '-03', '-02', '-01', '+00', '+01', '+02', '+03', '+04', '+05', '+06', '+07', '+08', '+09', '+10', '+11', '+12', '+13', '+14'].map(o => ({
  value: `${o}:00`,
  label: `${o}:00`
}));
const DayTimePicker = props => {
  const {
    date,
    time,
    offset,
    htmlID,
    autoFocus,
    isDisabled
  } = props;
  const {
    handleDayChange,
    handleTimeChange,
    handleOffsetChange,
    yearRangeFrom,
    yearRangeTo,
    yearPickerType
  } = props;
  const TODAY = new Date();
  return /*#__PURE__*/createElement("div", {
    id: htmlID
  }, /*#__PURE__*/createElement(DayPicker, {
    autoFocus: autoFocus,
    onSelectedChange: handleDayChange,
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType,
    startCurrentDateAt: date ? parseISO(date) : TODAY,
    selectedDate: date ? parseISO(date) : null
  }), /*#__PURE__*/createElement(Input, {
    type: "time",
    name: "time-picker",
    value: time,
    onChange: handleTimeChange,
    disabled: isDisabled || false,
    id: `${htmlID}-time`
  }), /*#__PURE__*/createElement(Select, {
    value: options.find(option => option.value === offset),
    options: options,
    onChange: ({
      value
    }) => {
      handleOffsetChange(value);
    },
    id: `${htmlID}-offset`
  }));
};

const TextDayPicker = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    date = '',
    onChange,
    format: displayFormat = 'do MMMM yyyy'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["date", "onChange", "format"]);

  const formatDate = newDate => newDate ? format(parseISO(newDate), displayFormat) : '';

  const [isEditing, setIsEditing] = useState(false);
  const [value, setValue] = useState({
    raw: date,
    formatted: formatDate(date)
  });
  const parseCache = useRef();
  useEffect(() => {
    // Parse the raw input. This may be a string such as 'Today'.
    const parsedDate = chrono.parseDate(value.raw); // If valid, convert it to ISO 8601.

    const isoDate = parsedDate ? formatISO(parsedDate, {
      representation: 'date'
    }) : null; // Pass it up the tree. The parent can handle the null case.

    onChange(isoDate);
    parseCache.current = isoDate;
  }, [value.raw]);

  const onFocus = () => {
    setIsEditing(true);
  };

  const onBlur = () => {
    setIsEditing(false);
    const raw = parseCache.current; // At this point, the parse cache should either be null or an ISO 8601 date.

    if (raw) {
      setValue({
        raw,
        formatted: formatDate(raw)
      });
    } else {
      setValue({
        raw: '',
        formatted: ''
      });
    }
  };

  const handleChange = ({
    target: {
      value: raw
    }
  }) => {
    setValue(oldValue => _objectSpread(_objectSpread({}, oldValue), {}, {
      raw
    }));
  };

  return /*#__PURE__*/React.createElement(Input, _extends({
    ref: ref,
    value: isEditing ? value.raw : value.formatted,
    placeholder: "Enter a date...",
    onFocus: onFocus,
    onBlur: onBlur,
    onChange: handleChange
  }, props));
});

let TextDayTimePicker = (_ref) => {
  let {
    date,
    onChange
  } = _ref,
      props = _objectWithoutProperties(_ref, ["date", "onChange"]);

  let [value, setValue] = useState('');
  let ref = useRef(null);
  useEffect(() => {
    setValue(formatDateTime(date));
  }, [date]);
  return jsx(Input, _extends({
    value: value,
    ref: ref,
    placeholder: "Enter a date and time...",
    onBlur: () => {
      let parsedDate = parseDate(value);
      onChange(parsedDate);
      setValue(formatDateTime(parsedDate));
    },
    onChange: event => {
      setValue(event.target.value);
    }
  }, props));
};

function formatDateTime(date) {
  // why are we using moment when it's so large and provides a mutable API?
  // because chrono uses it and consistency is nice and
  // will probably make bugs with conversion less likely
  return date ? moment.parseZone(date).format('h:mm A Do MMMM YYYY Z') : '';
}

function parseDate(value) {
  let [parsedDate] = chrono.parse(value);

  if (parsedDate === undefined) {
    return null;
  }

  let dateMoment = parsedDateToMoment(parsedDate);
  return dateMoment.toISOString( // passing true here keeps the offset in the iso string rather than
  // convert it to UTC which is the default to align with native JS Dates
  true);
}

function parsedDateToMoment(parsedDate) {
  // a copy of https://github.com/wanasit/chrono/blob/fe8db4e5e5f9b44215f96958c811f806458013e9/src/result.js#L102-L122
  // with one change, rather than adjusting the time to the timezone offset, we store the offset
  let dateMoment = moment();
  let currentTimezoneOffset = moment().utcOffset();
  let {
    start
  } = parsedDate;
  dateMoment.set('year', start.get('year'));
  dateMoment.set('month', start.get('month') - 1);
  dateMoment.set('date', start.get('day'));
  dateMoment.set('hour', start.get('hour'));
  dateMoment.set('minute', start.get('minute'));
  dateMoment.set('second', start.get('second'));
  dateMoment.set('millisecond', start.get('millisecond'));
  let targetTimezoneOffset = start.get('timezoneOffset') !== undefined ? start.get('timezoneOffset') : currentTimezoneOffset;
  dateMoment.utcOffset(targetTimezoneOffset, // passing true keeps the local time the same but changes the universal time
  // this is what we want because we're setting the local time above
  true);
  return dateMoment;
}

export { DayPicker, DayTimePicker, TextDayPicker, TextDayTimePicker };
