'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var core = require('@emotion/core');
var react = require('react');
var reactDom = require('react-dom');
var flushable = require('flushable');
var styled = require('@emotion/styled');
var reactPopper = require('react-popper');
var modalUtils = require('@arch-ui/modal-utils');
var theme = require('@arch-ui/theme');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var flushable__default = /*#__PURE__*/_interopDefault(flushable);
var styled__default = /*#__PURE__*/_interopDefault(styled);

// Styled Component
// ==============================

const TooltipElement = styled__default['default'].div({
  backgroundColor: theme.colors.N80,
  borderRadius: 3,
  color: 'white',
  fontSize: '0.75rem',
  fontWeight: 500,
  padding: `${theme.gridSize / 2}px ${theme.gridSize}px`,
  pointerEvents: 'none',
  // tooltips are non-interactive, they shouldn't get in the way of other elements
  zIndex: 2
});

const TooltipPositioner = ({
  targetNode,
  placement,
  style,
  className,
  children
}) => {
  const [popperElement, setPopperElement] = react.useState(null);
  const {
    styles
  } = reactPopper.usePopper(targetNode, popperElement, {
    placement,
    modifiers: [{
      name: 'hide',
      enabled: false
    }, {
      name: 'preventOverflow',
      enabled: false
    }]
  });
  return /*#__PURE__*/reactDom.createPortal(core.jsx("div", {
    ref: setPopperElement,
    css: {
      zIndex: 2000
    },
    style: _objectSpread(_objectSpread({}, style), styles.popper)
  }, core.jsx("div", {
    css: {
      margin: theme.gridSize
    }
  }, core.jsx(TooltipElement, {
    className: className
  }, children))), document.body);
}; // ==============================
// Stateful Component
// ==============================


const LISTENER_OPTIONS = {
  passive: true
};
let pendingHide;

const showTooltip = (fn, defaultDelay) => {
  const isHidePending = pendingHide && pendingHide.pending();

  if (isHidePending) {
    pendingHide.flush();
  }

  const pendingShow = flushable__default['default'](fn, isHidePending ? 0 : defaultDelay);
  return pendingShow.cancel;
};

const hideTooltip = (fn, defaultDelay) => {
  pendingHide = flushable__default['default'](fn, defaultDelay);
  return pendingHide.cancel;
};

const Tooltip = ({
  children,
  content,
  onHide,
  onShow,
  placement = 'bottom',
  className,
  hideOnMouseDown,
  hideOnKeyDown,
  delay = 300
}) => {
  const [isVisible, setIsVisible] = react.useState(false);
  const ref = react.useRef();
  react.useEffect(() => {
    const target = ref.current;

    if (!target) {
      throw new Error('You must pass the ref onto your target node.');
    }

    if (!target.nodeName) {
      throw new Error("It looks like you've passed the ref onto a component. You must pass the ref onto your target node.");
    }

    let cancelPendingSetState = () => {};

    const cancel = () => {
      cancelPendingSetState();
      setIsVisible(false);
    };

    const handleMouseEnter = () => {
      cancelPendingSetState();

      if (isVisible) {
        return;
      }

      if (hideOnMouseDown && target) {
        target.addEventListener('mousedown', cancel, LISTENER_OPTIONS);
      }

      if (hideOnKeyDown) {
        document.addEventListener('keydown', cancel, LISTENER_OPTIONS);
      }

      cancelPendingSetState = showTooltip(() => setIsVisible(true), delay);
    };

    const handleMouseLeave = () => {
      cancelPendingSetState();

      if (!isVisible) {
        return;
      }

      if (hideOnMouseDown && target) {
        target.removeEventListener('mousedown', cancel, LISTENER_OPTIONS);
      }

      if (hideOnKeyDown) {
        document.removeEventListener('keydown', cancel, LISTENER_OPTIONS);
      }

      cancelPendingSetState = hideTooltip(() => setIsVisible(false), delay);
    };

    target.addEventListener('mouseenter', handleMouseEnter, LISTENER_OPTIONS);
    target.addEventListener('mouseleave', handleMouseLeave, LISTENER_OPTIONS);
    return () => {
      cancelPendingSetState();

      if (target) {
        target.removeEventListener('mouseenter', handleMouseEnter, LISTENER_OPTIONS);
        target.removeEventListener('mouseleave', handleMouseLeave, LISTENER_OPTIONS);
      }
    };
  }, [isVisible]);
  return core.jsx(react.Fragment, null, children(ref), core.jsx(modalUtils.TransitionProvider, {
    isOpen: isVisible,
    onEntered: onShow,
    onExited: onHide
  }, transitionState => core.jsx(TooltipPositioner, {
    targetNode: ref.current,
    placement: placement,
    className: className,
    style: modalUtils.fade(transitionState)
  }, content)));
};

exports.default = Tooltip;
