"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntrospectionEngine = exports.IntrospectionError = exports.IntrospectionPanic = void 0;
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("@prisma/debug"));
const byline_1 = __importDefault(require("./utils/byline"));
const debugCli = debug_1.default('IntrospectionEngine:cli');
const debugRpc = debug_1.default('IntrospectionEngine:rpc');
const debugStderr = debug_1.default('IntrospectionEngine:stderr');
const debugStdin = debug_1.default('IntrospectionEngine:stdin');
const fs_1 = __importDefault(require("fs"));
const now_1 = require("./utils/now");
const panic_1 = require("./panic");
const resolveBinary_1 = require("./resolveBinary");
class IntrospectionPanic extends Error {
    constructor(message, rustStack, request) {
        super(message);
        this.rustStack = rustStack;
        this.request = request;
    }
}
exports.IntrospectionPanic = IntrospectionPanic;
class IntrospectionError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
exports.IntrospectionError = IntrospectionError;
let messageId = 1;
/* tslint:disable */
class IntrospectionEngine {
    constructor({ debug, cwd } = {
        debug: false,
        cwd: process.cwd(),
    }) {
        this.listeners = {};
        this.messages = [];
        this.isRunning = false;
        if (debug) {
            debug_1.default.enable('IntrospectionEngine*');
        }
        this.debug = Boolean(debug);
        this.cwd = cwd || process.cwd();
    }
    stop() {
        if (this.child) {
            this.child.kill();
            this.isRunning = false;
        }
    }
    rejectAll(err) {
        Object.entries(this.listeners).map(([id, listener]) => {
            listener(null, err);
            delete this.listeners[id];
        });
    }
    registerCallback(id, callback) {
        this.listeners[id] = callback;
    }
    getDatabaseDescription(schema) {
        return this.runCommand(this.getRPCPayload('getDatabaseDescription', { schema }));
    }
    getDatabaseVersion(schema) {
        return this.runCommand(this.getRPCPayload('getDatabaseVersion', { schema }));
    }
    introspect(schema, force) {
        this.lastUrl = schema;
        return this.runCommand(this.getRPCPayload('introspect', { schema, force }));
    }
    debugPanic() {
        return this.runCommand(this.getRPCPayload('debugPanic', undefined));
    }
    listDatabases(schema) {
        this.lastUrl = schema;
        return this.runCommand(this.getRPCPayload('listDatabases', { schema }));
    }
    getDatabaseMetadata(schema) {
        this.lastUrl = schema;
        return this.runCommand(this.getRPCPayload('getDatabaseMetadata', { schema }));
    }
    handleResponse(response) {
        let result;
        try {
            result = JSON.parse(response);
        }
        catch (e) {
            console.error(`Could not parse introspection engine response: ${response.slice(0, 200)}`);
        }
        if (result) {
            if (result.backtrace) {
                // if there is a backtrace on the result, it's probably an error
                console.log(result);
            }
            if (!result.id) {
                console.error(`Response ${JSON.stringify(result)} doesn't have an id and I can't handle that (yet)`);
            }
            if (!this.listeners[result.id]) {
                console.error(`Got result for unknown id ${result.id}`);
            }
            if (this.listeners[result.id]) {
                this.listeners[result.id](result);
                delete this.listeners[result.id];
            }
        }
    }
    init() {
        if (!this.initPromise) {
            this.initPromise = this.internalInit();
        }
        return this.initPromise;
    }
    internalInit() {
        return new Promise(
        // eslint-disable-next-line no-async-promise-executor, @typescript-eslint/no-misused-promises
        async (resolve, reject) => {
            var _a, _b;
            try {
                const binaryPath = await resolveBinary_1.resolveBinary('introspection-engine');
                debugRpc('starting introspection engine with binary: ' + binaryPath);
                this.child = child_process_1.spawn(binaryPath, {
                    env: process.env,
                    cwd: this.cwd,
                    stdio: ['pipe', 'pipe', 'pipe'],
                });
                this.isRunning = true;
                this.child.on('error', (err) => {
                    var _a;
                    console.error('[introspection-engine] error: %s', err);
                    (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
                    this.rejectAll(err);
                    reject(err);
                });
                (_a = this.child.stdin) === null || _a === void 0 ? void 0 : _a.on('error', (err) => {
                    var _a;
                    console.error(err);
                    (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
                });
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                this.child.on('exit', (code) => {
                    // handle panics
                    this.isRunning = false;
                    if (code === 255 && this.lastError && this.lastError.is_panic) {
                        const err = new panic_1.RustPanic(this.lastError.message, this.lastError.backtrace, this.lastRequest, panic_1.ErrorArea.INTROSPECTION_CLI, 
                        /* schemaPath */ undefined, 
                        /* schema */ this.lastUrl);
                        this.rejectAll(err);
                        reject(err);
                        return;
                    }
                    const messages = this.messages.join('\n');
                    let err;
                    if (code !== 0 || messages.includes('panicked at')) {
                        let errorMessage = chalk_1.default.red.bold('Error in introspection engine: ') + messages;
                        if (this.lastError && this.lastError.msg === 'PANIC') {
                            errorMessage = serializePanic(this.lastError);
                            err = new IntrospectionPanic(errorMessage, messages, this.lastRequest);
                        }
                        else if (messages.includes('panicked at')) {
                            err = new IntrospectionPanic(errorMessage, messages, this.lastRequest);
                        }
                        err = err || new Error(errorMessage);
                        this.rejectAll(err);
                        reject(err);
                    }
                });
                this.child.stdin.on('error', (err) => {
                    debugStdin(err);
                });
                byline_1.default(this.child.stderr).on('data', (data) => {
                    const msg = String(data);
                    this.messages.push(msg);
                    debugStderr(msg);
                    try {
                        const json = JSON.parse(msg);
                        if (json.backtrace) {
                            this.lastError = json;
                        }
                        if (json.level === 'ERRO') {
                            this.lastError = json;
                        }
                    }
                    catch (e) {
                        debugCli(e);
                    }
                });
                byline_1.default(this.child.stdout).on('data', (line) => {
                    this.handleResponse(String(line));
                });
                setImmediate(() => {
                    resolve();
                });
            }
            catch (e) {
                (_b = this.child) === null || _b === void 0 ? void 0 : _b.kill();
                reject(e);
            }
        });
    }
    async runCommand(request) {
        var _a;
        await this.init();
        if (process.env.FORCE_PANIC_INTROSPECTION_ENGINE) {
            request = this.getRPCPayload('debugPanic', undefined);
        }
        if ((_a = this.child) === null || _a === void 0 ? void 0 : _a.killed) {
            throw new Error(`Can't execute ${JSON.stringify(request)} because introspection engine already exited.`);
        }
        return new Promise((resolve, reject) => {
            this.registerCallback(request.id, (response, err) => {
                var _a, _b, _c, _d, _e, _f, _g;
                if (err) {
                    return reject(err);
                }
                if (typeof response.result !== 'undefined') {
                    resolve(response.result);
                }
                else {
                    if (response.error) {
                        (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
                        debugRpc(response);
                        if ((_b = response.error.data) === null || _b === void 0 ? void 0 : _b.is_panic) {
                            const message = (_e = (_d = (_c = response.error.data) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.message) !== null && _e !== void 0 ? _e : response.error.message;
                            reject(new panic_1.RustPanic(message, message, request, panic_1.ErrorArea.INTROSPECTION_CLI, 
                            /* schemaPath */ undefined, 
                            /* schema */ this.lastUrl));
                        }
                        else if ((_f = response.error.data) === null || _f === void 0 ? void 0 : _f.message) {
                            // Print known error code & message from engine
                            // See known errors at https://github.com/prisma/specs/tree/master/errors#prisma-sdk
                            let message = `${chalk_1.default.redBright(response.error.data.message)}\n`;
                            if ((_g = response.error.data) === null || _g === void 0 ? void 0 : _g.error_code) {
                                message =
                                    chalk_1.default.redBright(`${response.error.data.error_code}\n\n`) +
                                        message;
                                reject(new IntrospectionError(message, response.error.data.error_code));
                            }
                            else {
                                reject(new Error(message));
                            }
                        }
                        else {
                            const text = this.persistError(request, this.messages.join('\n'));
                            reject(new Error(`${chalk_1.default.redBright('Error in RPC')}\n Request: ${JSON.stringify(request, null, 2)}\nResponse: ${JSON.stringify(response, null, 2)}\n${response.error.message}\n\n${text}\n`));
                        }
                    }
                    else {
                        reject(new Error(`Got invalid RPC response without .result property: ${JSON.stringify(response)}`));
                    }
                }
            });
            if (this.child.stdin.destroyed) {
                throw new Error(`Can't execute ${JSON.stringify(request)} because introspection engine is destroyed.`);
            }
            debugRpc('SENDING RPC CALL', JSON.stringify(request));
            this.child.stdin.write(JSON.stringify(request) + '\n');
            this.lastRequest = request;
        });
    }
    persistError(request, message) {
        const filename = `failed-${request.method}-${now_1.now()}.md`;
        const file = `# Failed ${request.method} at ${new Date().toISOString()}
## RPC One-Liner
\`\`\`json
${JSON.stringify(request)}
\`\`\`

## RPC Input Readable
\`\`\`json
${JSON.stringify(request, null, 2)}
\`\`\`

## Stack Trace
\`\`\`bash
${message}
\`\`\`
`;
        fs_1.default.writeFileSync(filename, file);
        return `Wrote ${chalk_1.default.bold(filename)} with debugging information.
Please put that file into a gist and post it in Slack.
1. ${chalk_1.default.greenBright(`cat ${filename} | pbcopy`)}
2. Create a gist ${chalk_1.default.greenBright.underline(`https://gist.github.com/new`)}`;
    }
    getRPCPayload(method, params) {
        return {
            id: messageId++,
            jsonrpc: '2.0',
            method,
            params: params ? [{ ...params }] : undefined,
        };
    }
}
exports.IntrospectionEngine = IntrospectionEngine;
function serializePanic(log) {
    return `${chalk_1.default.red.bold('Error in introspection engine.\nReason: ')}${chalk_1.default.red(`${log.reason} in ${chalk_1.default.underline(`${log.file}:${log.line}:${log.column}`)}`)}

Please create an issue in the ${chalk_1.default.bold('prisma')} repo with the error üôè:
${chalk_1.default.underline('https://github.com/prisma/prisma/issues/new')}\n`;
}
//# sourceMappingURL=IntrospectionEngine.js.map