"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVersion = exports.formatSchema = exports.getConfig = exports.getDMMF = void 0;
const chalk_1 = __importDefault(require("chalk"));
const execa_1 = __importDefault(require("execa"));
const temp_write_1 = __importDefault(require("temp-write"));
const fs_1 = __importDefault(require("fs"));
const util_1 = require("util");
const debug_1 = __importDefault(require("@prisma/debug"));
const resolveBinary_1 = require("./resolveBinary");
const debug = debug_1.default('engineCommands');
const unlink = util_1.promisify(fs_1.default.unlink);
const MAX_BUFFER = 1000000000;
async function getDMMF({ datamodel, cwd = process.cwd(), prismaPath: queryEnginePath, datamodelPath, retry = 4, enableExperimental, }) {
    queryEnginePath = await resolveBinary_1.resolveBinary('query-engine', queryEnginePath);
    let result;
    try {
        let tempDatamodelPath = datamodelPath;
        if (!tempDatamodelPath) {
            try {
                tempDatamodelPath = await temp_write_1.default(datamodel);
            }
            catch (err) {
                throw new Error(chalk_1.default.redBright.bold('Get DMMF ') +
                    'unable to write temp data model path');
            }
        }
        const options = {
            cwd,
            env: {
                PRISMA_DML_PATH: tempDatamodelPath,
                RUST_BACKTRACE: '1',
                ...(process.env.NO_COLOR ? {} : { CLICOLOR_FORCE: '1' }),
            },
            maxBuffer: MAX_BUFFER,
        };
        const removedFeatureFlagMap = {
            insensitiveFilters: `${chalk_1.default.blueBright('info')} The preview flag "insensitiveFilters" is not needed anymore, please remove it from your schema.prisma`,
            atomicNumberOperations: `${chalk_1.default.blueBright('info')} The preview flag "atomicNumberOperations" is not needed anymore, please remove it from your schema.prisma`,
            connectOrCreate: `${chalk_1.default.blueBright('info')} The preview flag "connectOrCreate" is not needed anymore, please remove it from your schema.prisma`,
            transaction: `${chalk_1.default.blueBright('info')} The preview flag "transactionApi" is not needed anymore, please remove it from your schema.prisma`,
            transactionApi: `${chalk_1.default.blueBright('info')} The preview flag "transactionApi" is not needed anymore, please remove it from your schema.prisma`,
            uncheckedScalarInputs: `${chalk_1.default.blueBright('info')} The preview flag "uncheckedScalarInputs" is not needed anymore, please remove it from your schema.prisma`,
        };
        if (enableExperimental) {
            enableExperimental = enableExperimental
                .filter((f) => {
                const removeMessage = removedFeatureFlagMap[f];
                if (removeMessage) {
                    if (!process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
                        console.log(removeMessage);
                    }
                    return false;
                }
                return true;
            })
                .filter((e) => ![
                'middlewares',
                'aggregateApi',
                'distinct',
                'aggregations',
                'nativeTypes',
                'atomicNumberOperations',
            ].includes(e));
        }
        const experimentalFlags = enableExperimental &&
            Array.isArray(enableExperimental) &&
            enableExperimental.length > 0
            ? [`--enable-experimental=${enableExperimental.join(',')}`]
            : [];
        const args = [...experimentalFlags, '--enable-raw-queries', 'cli', 'dmmf'];
        result = await execa_1.default(queryEnginePath, args, options);
        if (!datamodelPath) {
            await unlink(tempDatamodelPath);
        }
        if (result.stdout.includes('Please wait until the') && retry > 0) {
            debug('Retrying after "Please wait until"');
            await new Promise((r) => setTimeout(r, 5000));
            return getDMMF({
                datamodel,
                cwd,
                prismaPath: queryEnginePath,
                datamodelPath,
                retry: retry - 1,
            });
        }
        // necessary, as sometimes the query engine prints some other stuff
        const firstCurly = result.stdout.indexOf('{');
        const stdout = result.stdout.slice(firstCurly);
        return JSON.parse(stdout);
    }
    catch (e) {
        debug('getDMMF failed', e);
        // If this unlikely event happens, try it at least once more
        if (e.message.includes('Command failed with exit code 26 (ETXTBSY)') &&
            retry > 0) {
            await new Promise((resolve) => setTimeout(resolve, 500));
            debug('Retrying after ETXTBSY');
            return getDMMF({
                datamodel,
                cwd,
                prismaPath: queryEnginePath,
                datamodelPath,
                retry: retry - 1,
            });
        }
        const output = e.stderr || e.stdout;
        if (output) {
            let json;
            try {
                json = JSON.parse(output);
            }
            catch (e) {
                //
            }
            let message = (json && json.message) || output;
            if (message.includes('debian-openssl-1.1.x: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory') ||
                message.includes('debian-openssl-1.0.x: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory')) {
                message += `\n${chalk_1.default.green(`Your linux installation misses the openssl package. You can install it like so:\n`)}${chalk_1.default.green.bold('apt-get -qy update && apt-get -qy install openssl')}`;
            }
            throw new Error(chalk_1.default.redBright.bold('Schema parsing\n') + message);
        }
        if (e.message.includes('in JSON at position')) {
            throw new Error(`Problem while parsing the query engine response at ${queryEnginePath}. ${result.stdout}\n${e.stack}`);
        }
        throw new Error(e);
    }
}
exports.getDMMF = getDMMF;
async function getConfig({ datamodel, cwd = process.cwd(), prismaPath: queryEnginePath, datamodelPath, ignoreEnvVarErrors, }) {
    var _a, _b, _c;
    queryEnginePath = await resolveBinary_1.resolveBinary('query-engine', queryEnginePath);
    let tempDatamodelPath = datamodelPath;
    if (!tempDatamodelPath) {
        try {
            tempDatamodelPath = await temp_write_1.default(datamodel);
        }
        catch (err) {
            throw new Error(chalk_1.default.redBright.bold('Get DMMF ') +
                'unable to write temp data model path');
        }
    }
    const args = ignoreEnvVarErrors ? ['--ignoreEnvVarErrors'] : [];
    try {
        const result = await execa_1.default(queryEnginePath, ['cli', 'get-config', ...args], {
            cwd,
            env: {
                PRISMA_DML_PATH: tempDatamodelPath,
                RUST_BACKTRACE: '1',
            },
            maxBuffer: MAX_BUFFER,
        });
        if (!datamodelPath) {
            await unlink(tempDatamodelPath);
        }
        const data = JSON.parse(result.stdout);
        if (((_c = (_b = (_a = data.datasources) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.provider) === null || _c === void 0 ? void 0 : _c[0]) === 'sqlite' &&
            data.generators.some((g) => g.previewFeatures.includes('createMany'))) {
            throw new Error(`Database provider "sqlite" and the preview feature "createMany" can't be used at the same time.
Please either remove the "createMany" feature flag or use any other database type that Prisma supports: postgres, mysql or sqlserver.`);
        }
        return data;
    }
    catch (e) {
        if (e.stderr || e.stdout) {
            const error = e.stderr ? e.stderr : e.stout;
            let jsonError, message;
            try {
                jsonError = JSON.parse(error);
                message = `${chalk_1.default.redBright.bold('Get config ')}\n${chalk_1.default.redBright(jsonError.message)}\n`;
                if (jsonError.error_code) {
                    if (jsonError.error_code === 'P1012') {
                        message =
                            chalk_1.default.redBright(`Schema Parsing ${jsonError.error_code}\n\n`) +
                                message;
                    }
                    else {
                        message = chalk_1.default.redBright(`${jsonError.error_code}\n\n`) + message;
                    }
                }
            }
            catch (e) {
                // if JSON parse / pretty handling fails, fallback to simple printing
                throw new Error(chalk_1.default.redBright.bold('Get config ') + error);
            }
            throw new Error(message);
        }
        throw new Error(chalk_1.default.redBright.bold('Get config: ') + e);
    }
}
exports.getConfig = getConfig;
async function formatSchema({ schemaPath, schema, }) {
    if (!schema && !schemaPath) {
        throw new Error(`Paramater schema or schemaPath must be passed.`);
    }
    const prismaFmtPath = await resolveBinary_1.resolveBinary('prisma-fmt');
    const showColors = !process.env.NO_COLOR && process.stdout.isTTY;
    const options = {
        env: {
            RUST_BACKTRACE: '1',
            ...(showColors ? { CLICOLOR_FORCE: '1' } : {}),
        },
        maxBuffer: MAX_BUFFER,
    };
    let result;
    if (schemaPath) {
        if (!fs_1.default.existsSync(schemaPath)) {
            throw new Error(`Schema at ${schemaPath} does not exist.`);
        }
        result = await execa_1.default(prismaFmtPath, ['format', '-i', schemaPath], options);
    }
    else if (schema) {
        result = await execa_1.default(prismaFmtPath, ['format'], {
            ...options,
            input: schema,
        });
    }
    return result.stdout;
}
exports.formatSchema = formatSchema;
async function getVersion(enginePath, binaryName = 'query-engine') {
    enginePath = await resolveBinary_1.resolveBinary(binaryName, enginePath);
    const result = await execa_1.default(enginePath, ['--version'], {
        maxBuffer: MAX_BUFFER,
    });
    return result.stdout;
}
exports.getVersion = getVersion;
//# sourceMappingURL=engineCommands.js.map