import { DataSource, GeneratorConfig } from '@prisma/generator-helper';
import { Platform } from '@prisma/get-platform';
export interface DatasourceOverwrite {
    name: string;
    url: string;
}
export interface EngineConfig {
    cwd?: string;
    dirname?: string;
    datamodelPath: string;
    enableDebugLogs?: boolean;
    enableEngineDebugMode?: boolean;
    prismaPath?: string;
    fetcher?: (query: string) => Promise<{
        data?: any;
        error?: any;
    }>;
    generator?: GeneratorConfig;
    datasources?: DatasourceOverwrite[];
    showColors?: boolean;
    logQueries?: boolean;
    logLevel?: 'info' | 'warn';
    env?: Record<string, string>;
    flags?: string[];
    useUds?: boolean;
    clientVersion?: string;
    enableExperimental?: string[];
    engineEndpoint?: string;
    activeProvider?: string;
}
declare type GetConfigResult = {
    datasources: DataSource[];
    generators: GeneratorConfig[];
};
export declare type Deferred = {
    resolve: () => void;
    reject: (err: Error) => void;
};
export declare type StopDeferred = {
    resolve: (code: number | null) => void;
    reject: (err: Error) => void;
};
export declare type EngineEventType = 'query' | 'info' | 'warn' | 'error' | 'beforeExit';
export declare class NodeEngine {
    private logEmitter;
    private showColors;
    private logQueries;
    private logLevel?;
    private env?;
    private flags;
    private port?;
    private enableDebugLogs;
    private enableEngineDebugMode;
    private child?;
    private clientVersion?;
    private lastPanic?;
    private globalKillSignalReceived?;
    private startCount;
    private enableExperimental;
    private engineEndpoint?;
    private lastErrorLog?;
    private lastRustError?;
    private useUds;
    private socketPath?;
    private getConfigPromise?;
    private stopPromise?;
    private beforeExitListener?;
    private dirname?;
    private cwd;
    private datamodelPath;
    private prismaPath?;
    private stderrLogs;
    private currentRequestPromise?;
    private platformPromise?;
    private platform?;
    private generator?;
    private incorrectlyPinnedBinaryTarget?;
    private datasources?;
    private startPromise?;
    private versionPromise?;
    private engineStartDeferred?;
    private engineStopDeferred?;
    private undici?;
    private lastQuery?;
    private lastVersion?;
    private lastActiveProvider?;
    private activeProvider?;
    /**
     * exiting is used to tell the .on('exit') hook, if the exit came from our script.
     * As soon as the Prisma binary returns a correct return code (like 1 or 0), we don't need this anymore
     */
    constructor({ cwd, datamodelPath, prismaPath, generator, datasources, showColors, logLevel, logQueries, env, flags, clientVersion, enableExperimental, engineEndpoint, enableDebugLogs, enableEngineDebugMode, dirname, useUds, activeProvider, }: EngineConfig);
    private setError;
    private checkForTooManyEngines;
    private resolveCwd;
    on(event: EngineEventType, listener: (args?: any) => any): void;
    emitExit(): Promise<void>;
    getPlatform(): Promise<Platform>;
    private getQueryEnginePath;
    private handlePanic;
    private resolvePrismaPath;
    private getPrismaPath;
    private getFixedGenerator;
    printDatasources(): string;
    /**
     * Starts the engine, returns the url that it runs on
     */
    start(): Promise<void>;
    private getEngineEnvVars;
    private internalStart;
    stop(): Promise<void>;
    /**
     * If Prisma runs, stop it
     */
    _stop(): Promise<void>;
    kill(signal: string): void;
    /**
     * Use the port 0 trick to get a new port
     */
    protected getFreePort(): Promise<number>;
    getConfig(): Promise<GetConfigResult>;
    _getConfig(): Promise<GetConfigResult>;
    version(forceRun?: boolean): Promise<string>;
    internalVersion(): Promise<string>;
    request<T>(query: string, headers: Record<string, string>, numTry?: number): Promise<T>;
    requestBatch<T>(queries: string[], transaction?: boolean, numTry?: number): Promise<T>;
    private get hasMaxRestarts();
    /**
     * If we have request errors like "ECONNRESET", we need to get the error from a
     * different place, not the request itself. This different place can either be
     * this.lastRustError or this.lastErrorLog
     */
    private throwAsyncErrorIfExists;
    private getErrorMessageWithLink;
    private handleRequestError;
    private graphQLToJSError;
}
export {};
